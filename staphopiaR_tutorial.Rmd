---
title: "Staphopia tutorial"
output:
  html_notebook:
    toc: true
    theme: united
---

## About the tutorial

The goal of the tutorial is to preview most of current functions and comment a little on the output.  The basic approach is formulate a query to pull data from the Staphopia API using one of the ```get_``` functions.  The resulting data frame can be processed using various local functions.  Some examamples of downstream processing are described.  The underlying philosophy is to provide, as much as possible, the raw output of many of the prediction programs in the Staphopia pipeline.  This allows to the user to play around with paraemters to customize calling of results. 

## Prerequisites

Install staphopia-r and test as described [here](https://github.com/staphopia/staphopia-r). You may choose to create a token for the staphopia API but the tutorial below is restricted to a small number of samples that can be accessed without an account.

Load libraries used in this tutorial (you may have to install first).

```{r message=FALSE}
library(staphopia)
library(dplyr)
library(ggplot2)
library(Biostrings)
library(phangorn) # check still use
library(purrr) # check still use
library(ape) 
library(assertthat)
```

## Creating a sample set

There are multiple ways to gather a set of genomes ("samples" in Staphopia) for analysis.  There are some pre-set collections of samples gathered under "tags".  A list of tags can be generated by ```get_all_tags```.

The difference between ```get_all_tags``` and ```get_public_tags``` is that the former command could include private samples that have not yet been submitted to NCBI.  We use "public" to mean that that the data has been submitted to NCBI/ENA and is freely available for download.

```{r}
tags <- get_all_tags()
head(tags)
```

The result is a list of tag names and matching tag_id.  These are mostly ENA/NCBI project acccessions or PubMed IDs (PMIDs) of publications but tags are a way of collecting samples together based on other criteria.  The top results from ```get_samples_by_tag``` are lists of projects that have "Gold" standard quality, are avaialble to the public, published with each coming from a different sequence type (ST).   These are test set open to the public without requiring a logon and token.  The '-20', '-50' etc mean 20 and 50 samples, respectively.

These samples can be accessed by ```get_samples_by_tag```.
```{r}
public50 <- get_samples_by_tag(4010)
head(public50)
```
The six columns are the internal staphopia sample_id; the name (generally, NCBI Experiment accession number), whether the samples are public (ie in the public domain, not private to the individual user), whether published, the ST (if not typeable under the currrent PubMLST database a '0' is recorded) and the quality rank (3 = "Gold").


There are alternative methods to get lists of samples - see the *staphopia-r* documentation. Some examples are: ```get_public_samples```, which returns all public sampes and  ```get_samples_by_name```, which searches sample names by a text string. These generally require a staphopia account/token.  Pulling large numbers of samples can slow down analysis.


## Exploring SNPs and Indels 

Coming soon is an annotation table with links N315 gene name with its own annotation_id linked to the more global 'product_id' - see [Genes and Contigs].  The table will also have the N315 coordinates.

```{r}
#get_annotation_table()  TODO
```

Get all SNPs in the samples associated with annotation_id 17
```{r}
public50_snp_range <- get_snps(public50$sample_id, annotation_id = 17)
head(public50_snp_range)
```

Each SNP has its own ID (based on position).  The columns including and after "AC" are quality metrics specific for this program.  "reference_id" is an internal ID that, in this case, means that the N315 chromosome was used.  All positions are based on the N315 chromosome, in this case. 

You can also extract snps based on a range of positions in the N315 sequence

```{r}
get_snps(public50$sample_id, start = 20800, end = 21000)
```



You can perform the query in reverse and pull samples that have a particular SNP
```{r}
get_samples_by_snp(62405)

```

You can get counts of SNPs across the global set at a particular annotation_id or range, in this case annotation_id = 17
```{r}
ann17_snps <- get_variant_count_by_position(ids = 17, is_annotation = TRUE)
head(ann17_snps)
```
The tables summarizes the number of synonymous and nonsynonymous SNPs at each position and number of times the position was covered by an indel.

barplot
```{r}
# TODO
```


Get indels for a given sample

```{r}
indels23942 <- get_indels(public50$sample_id[1])
head(indels23942)
```
These indels were called using the GATC program.   Each indel at a given position inserts or deletes a certain of bases is given a unique id. 

Another way of running this query is to look for all indels in a particular annotation_id across a set of samples.

```{r}
indels_in_ann274 <- get_indels(public50$sample_id, annotation_id = 274)
indels_in_ann274
```

We can query the reverse way.  If we are looking for a particular indel, we can get the strains that have it.  Indel 549 is common in these strains.  if it were of interest we can use this approach.

```{r}
get_samples_by_indel(549)
```


## Genes and contigs 

Genes are predicted on de novo assembled contigs using PROKKA. Each annotated function is associated with a 'product_id'.  ```get_gene_products``` pulls a list of all products.  
```{r}
gp <- get_gene_products()
head(gp)
```

This can also be used to search directly for text matches, using the ```query``` modifier.

```{r}
get_gene_products(query = "mecA")
```
mecA is product_id 2281.  The "inference" column is the NCBI protein id of the target used by PROKAA to make the funcional identification.

This information can be used to pull down information about mecA genes in the public50 set.

```{r}
#
public50_mecA_genes <- get_genes(public50$sample_id,product_id=2281)
public50_mecA_genes
```

The "locus_tag" uses the sample_name to create a unique identifier for the genes. The start and the end are the coordinates on the contig with the sample.  The DNA and protein sequence of the gene and gene_product are also available.

A stringset of the genes can be created using the Bioconductor Biostrings pakage.
```{r}
mecA_stringset <- DNAStringSet(public50_mecA_genes$dna)
names(mecA_stringset) <- public50_mecA_genes$locus_tag
mecA_stringset
```
Note that some of these genes have been truncated, probably by contig gaps.

Here is a quick and dirty way to plot the relationships of the full_length sequences (length = 2007 nt).  Note the neighbor-joining tree formatting will require some attention to avoid label overlaps .

```{r}
mecA_stringset2 <- mecA_stringset[width(mecA_stringset) == 2007]
mecA_bin <- as.DNAbin(mecA_stringset2)
dm <- dist.dna(mecA_bin)
njtree <- nj(dm)
plot(njtree,show.tip.label = T, cex = 0.5, type = 'unrooted')
```

You can use ```get_genes`` to pull all the gene locations for a sample.  This can be used to pull out individual contigs by filtering the data frame.  For example, from the data frame above ("public50_mecA_genes"), we can see that on sample 459, mecA is on contig 7.

```{r}
sample459_contig7 <- get_genes(sample_id = 459) %>%
  filter(contig == 7)
sample459_contig7
```

There are 138 features (CDS, mRNA etc) on this contig.

*<TODO - genoplotr graph>*

```get_assembly_contigs``` returns a list of the raw de novo assembled contig data for either assemblies marker as "plasmids" by SPAdes or not.  Columns give basic information and sequence as raw text.  Only contigs > 200 bp were from the de novo are stored in the database.  The header is the description in the fasta file if downloaded.  The first part is the <sample_id>|<ENA accession>|<contig number>  The contig number starts at 1 and counts up for each sample.

```{r}
contigs450 <- get_assembly_contigs(public50$sample_id[2], plasmids = F)
contigs450_plasmids <- get_assembly_contigs(public50$sample_id[2], plasmids = T)
head(contigs450)
```

## Writing sequence data to hard drive

There are 3 functions for writing contigs, plasmid contigs and proteins, respectively from a project to a local fasta_file. These are ```write_assembly```, ```write_genes``` and ```write_proteins```.  They all work the same way, with a default of the current local directory as the path to download. ```write_assembly``` allows filtering by minimum coverage and selection of whether plasmids or non-plasmids are downloaded. The following commands write out the data from sample_id 440.

```{r}
write_assembly(public50$sample_id[2], coverage = 2, plasmids = F)
write_genes(public50$sample_id[2])
write_proteins(public50$sample_id[2])
```

The section above ("Genes and Contigs") illustrated an alternative approach, where sets of DNA contigs, genes and proteins can be used to create a DNAStringSet, which could then be saved using the ```writeXStringSet``` function.

## Metadata

Metadata about the sample is available through the ```get_metadata``` function.  The columns in the data frame are from the ENA.   At the present time (March 2018), this is almost all data from the ENA but we want to add metadata from publicaiotns to improve the usability of the *S. aureus* genome dataset.  

```{r}
public50_meta <- get_metadata(public50$sample_id)
head(public50_meta)
```

If you want to get more information about the publications that samples are linked to, these can be investigated by ```get_publications``` and ```get_citations```.  Note in same cases the link betwen sample_id and publicaiotn has been made through an BioProject accession number.  In these cases the sample_id may have been part of a larger set and not discussed individually in that publication.  

```{r}
get_publications(public50$sample_id[1:10]) 
get_citations(26969225)
```


## Genome assembly and sequence quality

Stats on the sequence quality of the samples at different stages of procesing are avialble using ```get_sequence_quality```.

```{r}
public50_qual <- get_sequence_quality(public50$sample_id)
head(public50_qual)
```

For each project there should be 4 rows, representing the original data (downloaded from ENA), then after the adapter removal, after error correction by SPAdes (ecc) and then after the final cleanup to remove any short and/or low quality reads. 

You can get a snapshot of the assembly metrics for each sample using ```get_assembly_stats```.

```{r}
public50_asm_stats <- get_assembly_stats(public50$sample_id)
head(public50_asm_stats)
```

It is notable that some of these gold quality projects have surprsing high numbers of contigs, for example sample 4065 has 2132 contigs.  In these projects the reason is often a lot of short, low coverage contigs.  

```{r}
contigs4065 <- get_assembly_contigs(4065)
```

These can be safely removed by setting a low coverage filter.  We leave it up to the user how to do this post-assembly filtering for their own projects.

```{r}
contigs4065_filtered <-  contigs4065 %>%
  filter(coverage > 10)
nrow(contigs4065_filtered)
sum(contigs4065_filtered$length)
```

## Antibiotic resistance 

Can get more information about the data underlying these calls through ```get_resistance_results```.
```{r}
public50_res <- get_resistance_results(public50$sample_id)
head(public50_res)
```
This is the raw [ARIBA report file output](https://github.com/sanger-pathogens/ariba/wiki/Task:-run)

### Looking at tetracycline resistance clusters 

```{r}
public50_tet <- filter(public50_res,resistance_class_id == 10) %>%
  select(sample_id,cluster) %>%
  unique()
head(public50_tet)  
```

This dataframe is the tet clusters types across the strains.  

```{r}
barplot(table(public50_tet$cluster))
```
 Note that tet38 is a conserved chromosomal gene, so is present in all strains and thus 



### Looking at beta Lactam resistance mechanisms


```{r}
public50_bla <- filter(public50_res,resistance_class_id == 13) %>%
  select(sample_id,mechanism) %>%
  unique()
  
```

Visualization of number of samples with each beta lactam resistance mechanism


```{r}
barplot(table(public50_bla$mechanism), cex.names= 0.8)
```

## SCCmec 

SCCmec  is a test for storing BLASTN and TBLASTN resuls toward examing specific features of *S. aureus* genetics.  In this case, the SCCmec mobile cassettes  responsible for MRSA.  We have a preliminary set of tables from BLAST typing primers and protiens.

### SCCmec background

Whether a *S. aureus* sample is methicillin-resistant (MRSA) or methicillin-susceptible (MSSA) is determined by the presence of the mecA gene on the SCCmec cassette. There are at least 11 known SCCmec types, some of which have multiple subtypes. Traditionally, MRSA determination is a lab-based test using PCR primers specific for each type. The SCCmec type is important as resistances and virulence factors are associated with certain types. A table of which hits determine which SCCmec type can be found at [SCCmec.org SCCmec Typing](http://www.sccmec.org/Pages/SCC_TypesEN.html).

The table looks like this:

|SCCmec types |  ccr complexes | mecA complexes|
|-------------|:-------------:|:-----:|
|I | A1,B1 | B|
|II |A2,B2 | A|
|III| A3,B3 | A|
|IV | A2,B2 | B|
|V | C1 | C2|
|VI | A4,B4 | B|
|VII |C1 | C1|
|VIII | A4,B4 | A|
|IX | A1,B1 | C2|
|X | A1,B6 | C1|
|XI | A1,B3 | E|

So if a sample has primer matches to *ccrA4*, *ccrB4* and *mecA (A)*, then looking at the above table, the SCCmec type would be type VIII.

The way to get the "TL;DR" is to use ```get_sccmec_type```.  These results are based on perfect BLASTN matches of the primers to the assembled contig.
```{r}
public50_sccmec <- get_sccmec_type(public50$sample_id)
head(public50_sccmec)
```

This is a work in progress.  We are not attempting to type classes X-XIII currently. The table shows whether the sample was typed as SCCmec I-IX and a 'mecA' column additionally reports whether specifically the mecA gene primers matched, as would be expected for a MRSA strain.  You can see that some MRSA+ strains dont have a SCCmec type and some samples have multiple MRSA types.


```{r}
n <- rowSums(public50_sccmec[,2:10])
public50_sccmec$n <- n 
public50_sccmec %>% select(sample_id,meca,n)
```

This typing is based only on the primer BLAST results at hte moment.  Using the ```get_sccmec_primer_hits()``` function we can get a look at which primers were found in each sample.

```{r}
public50_sccmec_primers <- get_sccmec_primer_hits(public50$sample_id)
head(public50_sccmec_primers)
```
One useful metric to gauge the strength of the hit is Hamming distance - the number of changes between the query primer and the match.  A violin plot gives a look at the distribution of the those values across the sample.  This could be used to hel setting cutoffs.

```{r}
sccmec_pplot2 <- ggplot(public50_sccmec_primers, aes(x=title, y=hamming_distance)) + geom_violin() + theme(axis.text.x = element_text(angle = 90, hjust = 1)) 
sccmec_pplot2
```

Its also useful to look at the protein tBLAST hits.  In this output, a new field called "shorter"" is created with an abbreviated protein name.

```{r}
public50_sccmec_proteins <- get_sccmec_protein_hits(public50$sample_id) %>%
  mutate(shorter = gsub("\\|UniRef.+"," ",title)) 
head(public50_sccmec_proteins)
```

You canmake make a summary of the likely strong hits (in this case, mismatch + gaps less than 20 and plot)

```{r}
public50_sccmec_proteins_filtered <- public50_sccmec_proteins %>%
  filter(mismatch + gaps < 40)
sccmec_pplot <- ggplot(public50_sccmec_proteins_filtered, aes(x=shorter)) + geom_bar() + theme(axis.text.x = element_text(angle = 90, hjust = 1)) 
sccmec_pplot
```

## Virulence genes 

Similar to resistance, we used Ariba to run the samples against the [VFDB](http://www.mgc.ac.cn/VFs/main.htm)

```{r}
public50_vir <- get_virulence_results(public50$sample_id)
head(public50_vir)
```

Summarize and plot

```{r}
public50_vir_summ <- public50_vir %>%
  select(sample_id,cluster_name) %>%
  unique()
```

```{r}
table(public50_vir_summ$cluster_name)
```
This shows that many hits are core and present in all 50 samples (although not nescessarily functional in the case of the cap locus genes for example)

```{r}
variable_vir_genes <- names(table(public50_vir_summ$cluster_name))[table(public50_vir_summ$cluster_name) < 50]
public50_vir_summ_var <- public50_vir_summ %>%
  filter(cluster_name %in% variable_vir_genes)
```


```{r}
virplot <- ggplot(public50_vir_summ_var, aes(x=cluster_name)) + geom_bar() + theme(axis.text.x = element_text(angle = 90, hjust = 1)) 
virplot
```


## MLST and cgMLST

The 'classic' 7 locus MLST for each sample can be obtained using ```get_sequence_type```.  This returns the MLST called idependently by Ariba, Mentalist and BLAST methods.  The main purpose of this function is allow ambiguous calls to be investigated.

```{r}
public50_MLST <- get_sequence_type(public50$sample_id)
head(public50_MLST)
```



Here is how to obtain cgMLST profiles for each sample.

```{r}
public50_cgmlst <- get_cgmlst(public50$sample_id)
head(public50_cgmlst)
```

The table shows the allele number for each locus for each sample.  We created a function (```cgmlst_distance```) to get the paiwise Hamming distances (ie the number of allele changes) between each sample.  Note: this function will be get slow if the dataframe contains a lot of samples. Underneath, the function is run on the first ten samples.

```{r}
public50_cgmlst_matrix <- cgmlst_distance(public50_cgmlst[1:10,])
head(public50_cgmlst_matrix)
```

The column and row names are the sample_ids.  The values are the Hamming distances between the two cgMLST patterns.

## Rapid core genome trees (Unfinished)

```{r}
public50_var_genes <- get_variant_gene_sequence(sample_ids = public50$sample_id[1:10], annotation_ids = c(2,3,4))
```


## Quality control assertions (Unfinished)

The Staphopia database and R package are being tweaked frequently.  If any of these assertions returns false it means that there may have been some subtle changes that may affect the results in the tutorial.

```{r}
see_if(public50$sample_id[1] == 23942, msg = "public-50 samples changed")
see_if(ncol(public50) == 6, msg = "public-50 columns ne 6")

see_if(public50_asm_stats %>% filter(sample_id == 4065) %>% select(total_contig) == 2132, msg = "sample 4065 total contigs changed")
```


## Session Info
```{r}
session_info()
```

