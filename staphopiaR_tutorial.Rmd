---
title: "Staphopia tutorial"
output:
  html_notebook:
    toc: true
    theme: united
---


Load libraries used in this tutorial (you may have to download and install.

```{r}
library(staphopia)
library(dplyr)
library(Biostrings)
library(phangorn)
library(purrr)
library(ape)
```

## Creating a sample set

There are multiple ways to gather a set of genomes ("samples" in Staphopia) for analysis.  There are some pre-set collections of samples gathered under "tags".  A list of tags can be generated by ```get_all_tags```.

The difference between ```get_all_tags``` and ```get_public_tags``` is that the former command could include private samples that have not yet been submitted to NCBI.  We use "public" to mean that that the data has been submitted to NCBI/ENA and is freely available for download.

```{r}
tags <- get_all_tags()
head(tags)
```

The result is a list of tag names and matching tag_id.  These are mainly ENA/NCBI project acccessions or PubMed IDs (PMIDs) of publications.  The top results are lists of projects, which have "Gold" standard quality, are avaialble to the public, published and each coming from a different sequence type (ST).   These are test set open to the public without requiring a logon and token.  The '-20', '-50' etc mean 20 and 50 samples, respectively.

These samples can be accessed by ```get_samples_by_tag```.
```{r}
public50 <- get_samples_by_tag(4010)
head(public50)
```
The six columns are the internal staphopia sample_id; the name (generally, NCBI Experiment accession number), whether the samples are public (ie in the public domain, not private to the individual user), whether published, the ST (if not typeable under the currrent PubMLST database a '0' is recorded) and the quality rank (3 = "Gold").


There are alternative methods to get lists of samples - see the *staphopia-r* documentation. Some examples are: ```get_public_samples```, which returns all public sampes and  ```get_samples_by_name```, which searches sample names by a text string. These generally require a staphopia account/token.  Pulling large numbers of samples can slow down analysis.


## Exploring SNPs and Indels (unfinished)

Based on N315 reference genome coordinates
```{r}
graR_SNPs <- get_snps_in_bulk((708245*3):(708919*3))
rpoB_SNPs <- get_snps_in_bulk((579620*3):(583171*3))
walK_SNPs <- get_snps_in_bulk((25648*3):(27474*3))
```

look at one specific SNP
```{r}
snp2124752 <- get_samples_by_snp(graR_SNPs$id[33])
pub_sam %>% filter(sample_id %in% snp2124752)
```

count SNPs
```{r}
graR_SNP_Counts <- map_int(graR_SNPs$id,function(x) length(get_samples_by_snp(x)))   
```

add counts of SNPs to columns
```{r}
graR_ <- cbind(graR_SNPs,graR_SNP_Counts) 
```

barplot
```{r}
barplot(graR_SNP_Counts, main = "graR SNP distribution")
```
## Genes and contigs (unfinished)

Genes are predicted on de novo assembled contigs using PROKKA. Each annotated function is associated with a 'product_id'.  ```get_gene_products`` pulls a list of all products.  These can be searched for text matches.
```{r}
gp <- get_gene_products()
```


```{r}
#
prod33 <- get_genes(23942,product_id=1)

```


```get_assembly_contigs`` returns a list of the raw de novo assembled contig data for either assemblies marker as "plasmids" by SPAdes or not.  Columns give basic information and sequence as raw text.  Only contigs > 200 bp were from the de novo are stored in the database.  The header is the description in the fasta file if downloaded.  The first part is the <sample_id>|<ENA accession>|<contig number>  The contig number starts at 1 and counts up for each sample.

```{r}
contigs450 <- get_assembly_contigs(public50$sample_id[2], plasmids = F)
contigs450_plasmids <- get_assembly_contigs(public50$sample_id[2], plasmids = T)
head(contigs450)
```





create stringset
```{r}
IS256_out <- DNAStringSet(IS256$dna)
names(IS256_out) <- paste(IS256$sample_id,IS256$id,sep = "_")
IS256_out <- IS256_out[width(IS256_out)==1173]
```

phylogeny/ heat map

```{r}
IS256_bin <- as.DNAbin(IS256_out)
dm <- dist.dna(IS256_bin)
no_SNps <- as.matrix(as.integer(dm*1173))
hist(no_SNps)
njtree <- nj(dm)
temp <- as.matrix(dm)
heatmap(temp,cexRow = 0.2, cexCol = 0.2)
njtree <- midpoint(njtree)
plot(njtree,show.tip.label = T, cex = 0.5)
```

## Writing sequence data to hard drive


## Metadata

Metadata about the sample is available through the ```get_metadata``` function.  The columns in the data frame are from the ENA.   At the present time (March 2018), this is almost all data from the ENA but we want to add metadata from publicaiotns to improve the usability of the *S. aureus* genome dataset.  

```{r}
public50_meta <- get_metadata(public50$sample_id)
head(public50_meta)
```

*< TODO - pull pubmed id by samples >*

## Genome assembly and sequence quality

Stats on the sequence quality of the samples at different stages of procesing are avialble using ```get_sequence_quality```.


```{r}
public50_qual <- get_sequence_quality(public50$sample_id)
head(public50_qual)
```
 For each project there should be 4 rows, representing the original data (downloaded from ENA), then after the adapter removal, after error correction by SPAdes (ecc) and then after the final cleanup to remove any short and/or low quality reads. 


You can get a snapshot of the assembly metrics for each sample using ```get_assembly_stats```.

```{r}
public50_asm_stats <- get_assembly_stats(public50$sample_id)
head(public50_asm_stats)
```

It is notable that some of these gold quality projects have surprsing high numbers of contigs, for example sample 4065 has 2132 contigs.  In these projects the reason is often a lot of short, low coverage contigs.  

```{r}
contigs4065 <- get_assembly_contigs(4065)
```

These can be safely removed by setting a low coverage filter.  We leave it up to the user how to do this post-assembly filtering for their own projects.

```{r}
contigs4065_filtered <-  contigs4065 %>%
  filter(coverage > 10)
nrow(contigs4065_filtered)
sum(contigs4065_filtered$length)
```


## Antibiotic resistance


## SCCmec

This section is a test for storing BLASTN, TBLASTN and reference mapped sequences toward examing specific features of *S. aureus* genetics.  In this case, the SCCmec mobile cassettes  responsible for MRSA.

### SCCmec background

Whether a *S. aureus* sample is methicillin-resistant (MRSA) or methicillin-susceptible (MSSA) is determined by the presence of the mecA gene on the SCCmec cassette. There are at least 11 known SCCmec types, some of which have multiple subtypes. Traditionally, MRSA determination is a lab-based test using PCR primers specific for each type. The SCCmec type is important as resistances and virulence factors are associated with certain types. A table of which hits determine which SCCmec type can be found at [SCCmec.org SCCmec Typing](http://www.sccmec.org/Pages/SCC_TypesEN.html).

The table looks like this:

|SCCmec types |  ccr complexes | mecA complexes|
|-------------|:-------------:|:-----:|
|I | A1,B1 | B|
|II |A2,B2 | A|
|III| A3,B3 | A|
|IV | A2,B2 | B|
|V | C1 | C2|
|VI | A4,B4 | B|
|VII |C1 | C1|
|VIII | A4,B4 | A|
|IX | A1,B1 | C2|
|X | A1,B6 | C1|
|XI | A1,B3 | E|

So if a sample has primer matches to *ccrA4*, *ccrB4* and *mecA (A)*, then looking at the above table, the SCCmec type would be type VIII.

The way to get the "TL;DR" is to use ```get_sccmec_type```.  These results are based on perfect BLASTN matches of the primers to the assembled contig.
```{r}
public50_sccmec <- get_sccmec_type(public50$sample_id)
head(public50_sccmec)
```

The table shows whether the sample was typed as SCCmec I-XI and a 'mecA' column additionally reports whether specifically the mecA gene primers matched, as would be expected for a MRSA strain.  There are some problems with the summary.  Some MRSA+ strains dont have a SCCmec type and some samples have multiple MRSA types.

```{r}
n <- rowSums(public50_sccmec[,2:10])
public50_sccmec$n <- n 
public50_sccmec %>% select(sample_id,meca,n)
```


< to be continued>


We can use Staphopia, to get the BLAST hits associated with the primers to determine the SCCmec type (if applicable) for each of our demo samples. Using the ```get_sccmec_primer_hits()``` function we can get a look at which primers were found in each sample.


## Virulence genes

## Rapid core genome trees

## MLST and cgMLST

The 'classic' 7 locus MLST for each sample can be obtained using ```get_sequence_type```.  This returns the MLST called idependently by Ariba, Mentalist and BLAST methods.  The main purpose of this function is allow ambiguous calls to be investigated.

```{r}
public50_MLST <- get_sequence_type(public50$sample_id)
head(public50_MLST)
```



Here is how to obtain cgMLST profiles for each sample.

```{r}
public50_cgmlst <- get_cgmlst(public50$sample_id)
head(public50_cgmlst)
```

The table shows the allele number for each locus for each sample.  We created a function (```cgmlst_distance```) to get the paiwise Hamming distances (ie the number of allele changes) between each sample.  Note: this function will be get slow if the dataframe contains a lot of samples. Underneath, the function is run on the first ten samples.

```{r}
public50_cgmlst_matrix <- cgmlst_distance(public50_cgmlst[1:10,])
head(public50_cgmlst_matrix)
```

The column and row names are the sample_ids.  The values are the number Hamming distance.


## Quality control assertions

The Staphopia database and R package are being tweaked constantly.  If any of these assertions returns false it means that there may have been some subtle changes that may affect the results in the tutorial.

```{r}
library(assertthat)
see_if(public50$sample_id[1] == 23942, msg = "public-50 samples changed")
see_if(ncol(public50) == 6, msg = "public-50 columns ne 6")

see_if(public50_asm_stats %>% filter(sample_id == 4065) %>% select(total_contig) == 2132, msg = "sample 4065 total contigs changed")
```


## Session Info
```{r}
session_info()
```

